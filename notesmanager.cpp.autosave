#include "notesmanager.h"
#include <QString>


//********* SINGLETON ***************
NotesManager* NotesManager::instance_NotesManager = nullptr;

NotesManager* NotesManager::getInstance(){ //méthode qui vérifie qu'il n'y ait qu'une seule instance de NotesManager
    if(NotesManager::instance_NotesManager==nullptr)   // si l'instance n'existe pas
        NotesManager::instance_NotesManager = new NotesManager;    // on crée une instance
    return NotesManager::instance_NotesManager;
}

void NotesManager::libererInstance(){
    if(NotesManager::instance_NotesManager != nullptr) // si l'instance existe
        delete NotesManager::instance_NotesManager;    // on la supprime
    NotesManager::instance_NotesManager=nullptr;   // réinitialisation à nullptr
}


NotesManager::NotesManager():tab_notes(nullptr),nbNotes(0),nbMaxNotes(50) {}

NotesManager::~NotesManager(){  // relation de composition avec note => il faut supprimer toutes les notes
    save();
    for(unsigned int i=0; i<nbNotes; i++) delete tab_notes[i];
    delete[] tab_notes;
}


Note& NotesManager::getNote(const QString& id){
    for(unsigned int i=0; i<nbNotes; i++){
        if (tab_notes[i]->getId()==id) return *tab_notes[i];
    }
    throw NotesException("error, nonexistent note");
}

void NotesManager::ajouterNote(Note * n){
    // recherche si note existe déjà
    for(unsigned int i=0; i<nbNotes; i++){
        if (tab_notes[i]->getId()==n->getId()) throw NotesException("error, creation of an already existent note");
    }
    // capacité max ?
    if (nbNotes==nbMaxNotes){
        Note** newTab_Note= new Note*[nbMaxNotes+10];
        for(unsigned int i=0; i<nbMaxNotes; i++) newTab_Note[i]=tab_notes[i];
        Note** oldTab_note=tab_notes;
        tab_notes=newTab_Note;
        nbMaxNotes+=10;
        if (oldTab_note) delete[] oldTab_note;
    }
    //ajout de la note
    tab_notes[nbNotes++]=n;
}

void NotesManager::supprimerNote(Note * oldNote){
    // recherche si note existe déjà
    unsigned int i=0;
    while((tab_notes[i]->getId()!=oldNote->getId()) && i<nbNotes)
    {
        ++i;
    }
    // si la note n'est pas trouvé
    if(i==nbNotes)
        throw NotesException("error, deletion of a non existant note.");

    // décalage à gauche du tableau
    for(unsigned int j=i; j<nbNotes-1; j++){
        tab_notes[j]=tab_notes[j+1];
    }

    // suppression de la dernière note (en double) de tab_notes[j=nbNotes-1];
    delete tab_notes[nbNotes];
    delete oldNote;

    //actualisation du nombre de notes
    --nbNotes;
}

// TO DO : D'où restaurer une note ??
/*void NotesManager::restaurerNote(Note * n)
{


}
*/
/*void NotesManager::load(const QString& f) {
    if (filename!=f) save();
    filename=f;
    ifstream fin(filename); // open file
    if (!fin) throw NotesException("error, file does not exist");
    while(!fin.eof()&&fin.good()){
        char tmp[1000];
        fin.getline(tmp,1000); // get id on the first line
        if (fin.bad()) throw NotesException("error reading note id on file");
        Qstring id=tmp;
        fin.getline(tmp,1000); // get title on the next line
        if (fin.bad()) throw NotesException("error reading note title on file");
        Qstring title=tmp;
        fin.getline(tmp,1000); // get text on the next line
        if (fin.bad()) throw NotesException("error reading note text on file");
        Qstring text=tmp;
        Note* n=new Note(id,title,text);
        ajouterNote(n);
        if (fin.peek()=='\r') fin.ignore();
        if (fin.peek()=='\n') fin.ignore();
    }
    fin.close(); // close file
}*/

/*void NotesManager::save() const {
    ofstream fout(filename);
    for(unsigned int i=0; i<nbNotes; i++){
        fout<<*tab_notes[i];
    }
    fout.close();
}*/



void NotesManager::saveNotesManager(const QString & filename){
    QFile newFile(filename);
    if (!newFile.open(QIODevice::WriteOnly | QIODevice::Text))
        throw exception(QString("Error open file xml: cannot save file"));

    QXmlStreamWriter stream(&newFile);
    stream.setAutoFormatting(true);
    stream.writeStartDocument();
    for (unsigned int i=0; i < nbNotes; i++){
        stream.writeStartElement("Note");
        stream.writeStartElement("id", tab_notes[i]->getId());
        QString s_etat = enum_etat_to_string(tab_notes[i]->getEtat());
        stream.writeStartElement("Type_etat_note", s_etat);
        stream.writeStartElement("Date_creation", tab_notes[i]->getDateCreation().toString("dd.MM.yyyy hh::mm:ss"));
        //if (tab_notes[i]->getOrientee()) stream.writeStartElement("orientation","true");
        //else stream.writeStartElement("orientation","false");
        for (Note::iterator it_note = tab_notes[i]->begin(); it_note != tab_notes[i]->end(); it_note++){
            
            stream.writeStartElement("Version");
            //stream.writeStartElement("titre", (*it_note)->getTitle());
            //stream.writeStartElement("date_modif", (*it_note)->getDateModif().getId());
            /* TO DO :
            ajouter save pour les classes filles de version (multimedia, ...)


            */


            stream.writeEndElement();
        }
        stream.writeEndElement();
    }
    stream.writeEndElement();
    newFile.close();
}
/*QString dateStr = "2014-03-18 09:30:36";
QString fmt = "yyyy-MM-dd hh:mm:ss";
QDateTime dt = QDateTime::fromString(dateStr, fmt);
QString timeStr = dt.toString("hh:mm");
*/
/*void NotesManager::loadNotesManager(const QString & filename){
    QFile loadFile(filename);
    if (!loadFile.open(QIODevice::ReadOnly | QIODevice::Text))
        throw exception(QString("Error open file xml: cannot load file"));
    QXmlStreamReader xml(&loadFile);

    while(!xml.atEnd() && !xml.hasError()) {
        QXmlStreamReader::TokenType token = xml.readNext();
        if(token == QXmlStreamReader::StartDocument) continue;
         while(!(xml.tokenType() == QXmlStreamReader::EndElement && xml.name() == "relation")){
            xml.readNext();
            if (xml.tokenString() == QXmlStreamReader::StartElement){
                QString titre;
                QString description;
                bool orientee;
                if (xml.name() == "titre"){
                    xml.readNext();
                    titre = xml.text().toString();
                }
                if (xml.name() == "description"){
                    xml.readNext();
                    description = xml.text().toString();
                }
                if (xml.name() == "orientation"){
                    xml.readNext();
                    if (xml.text().toString() == "true") orientee = true;
                    else orientee = false;
                }

                Relation* relation;
                if (titre == "\ref") relation = relations[0];
                else relation = new RelationNormale(titre, description, orientee);
                //loop to get Couple
                while(!(xml.tokenType() == QXmlStreamReader::EndElement && xml.name() == "couple")){
                    QString label;
                    QString note1;
                    QString note2;
                    if (xml.tokenString() == QXmlStreamReader::StartElement){
                        if (xml.name() == "label"){
                            xml.readNext();
                            label=xml.text().toString();
                        }
                        if (xml.name() == "note1"){
                            xml.readNext();
                            note1=xml.text().toString();
                        }
                        if (xml.name() == "note2"){
                            xml.readNext();
                            note2=xml.text().toString();
                        }
                    }
                    xml.readNext();
                    Couple* newCouple = new Couple(&NotesManager->getNote(note1), &NotesManager->getNote(note2), label);
                    relation->ajouterCouple(newCouple);
                }
                if (titre != "\ref") ajouterRelation(relation);
            }
        }
    }
    if(xml.hasError()) {
        throw exception("Error parsing xml : cannot read file");
    }
    xml.clear();
}*/
